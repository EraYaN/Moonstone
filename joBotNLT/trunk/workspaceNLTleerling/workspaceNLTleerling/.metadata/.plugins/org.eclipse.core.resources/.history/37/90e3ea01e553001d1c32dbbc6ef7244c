package javaBot.Junior.Grid;

/** 
 * CuriousBeheavior is een aangepaste versie van FleeBehavior.
 * Leerlingen passen het gedrag aan in een aantal stappen:
 * 
 * Opdracht 2g - Bekijk deze code 
 * 
 * Opdracht 2h/j - Pas de code aan:
 * 	Zorg dat de robot naar je toe komt rijden.
 * 
 * Opdracht 2k+ - Zorg dat de robot niet te dichtbij komt.
 * 	Blijf op een afstand van 5 cm. Zoek uit welke waarde dat is.
 * 	De robot zelf is ongeveer 18 cm, de sensor lijn is 25 cm.
 * 	Merk op dat de code wat anders is dan in FleeBehavior.
 *  Er zijn z.g. State variabelen toegevoegd.
 *  Dit is gedaan ter voorbereiding van latere lessen.
 
 * 	Lesson 8a - Opnemen state definities
 * 	Lesson 8b - Opnemen basis architectuur
 * 	Lesson 8c - Opnemen maken random getallen
 * 	Lesson 8d - Code voor ACT clause
 * 	Lesson 8e - Code voor SENSE clause
 * 	Lesson 8f - Code voor Reason clause
 * 
 * 	Lesson 9a - Opnemen substates
 * 	Lesson 9b - Avoid Obstacle subroutine
 */

import com.muvium.apt.PeriodicTimer;

public class CuriousBehavior09 extends Behavior
{
	// Declaraties voor opdracht 2i
	private BaseController	joBot;
	private int state = stateInit;
	
	// Declaraties toegevoegd voor opdracht 9
	private static final int stateInit = 1;
	private static final int stateSense = 2;
	private static final int stateNeutral = 20;
	private static final int stateScared = 21;
	private static final int stateCurious = 22;	
	private static final int stateReason = 3;
	private static final int stateAct = 4;
	private static final int stateWander = 40;
	// Substates toegevoegd voor opdracht 9a
	private static final int stateSubInit = 50;
	private static final int stateBackup = 51;
	private int subState = 0;
	private int subCount = 0;
	private int lsl = 0;
	private int lsr = 0;
	
	private int threshold = 50;
	private int speedThreshold = 50;
	private int rnd1 = 0;
	private int rnd2 = 0;
	private int wait = 0;
	private int nextState = 0;
	private int prevSl = 0;
	private int prevSr = 0;
	private boolean senseFast = false;
	private boolean senseToMe = false;
	private int diff = 0;
	private int speed = 50;
	
	/**
	 * CuriousBehavior zorgt dat de robot naar een object toe rijdt.
	 */
	public CuriousBehavior09(BaseController initJoBot, PeriodicTimer initServiceTick,
			int servicePeriod)
	{
		super(initJoBot, initServiceTick, servicePeriod);
		joBot = initJoBot;	}

	public void doBehavior()
	{
		int sl = 0;
		int sr = 0;
		
		// Anders dan in FLeeBehavior wordt hier de state getest.
		// Deze dient voor opdracht 2i op nul (0) te staan. 
		// In volgende lessen gaan we deze variabele gebruiken.
		// De rest van de code is hetzelfde als in FleeBehavior.
		
		if (state == 0) {
			sl = joBot.getSensorValue(0);
			sr = joBot.getSensorValue(1);
			joBot.setStatusLeds(false, false, false);  // Turn leds off
			joBot.drive(0, 0);
			
		// Zorg voor opdracht 2j+ dat de robot niet te dichtbij komt
		// Dat doe je door gebruik te maken van een extra test
		// Die kijkt of de waarde niet hoger wordt dan bij 5cm afstand
		// Om die samen te voegen met de sensor waarde, gebruik je de
		// && (and) operator als volgt:
		// if ((sl > 200) && (sl < ???))  // Vul hier de juiste waarde in
			
			if ((sl > 200) && (sl < 500)) {
				joBot.setLed(joBot.LED_GREEN, true); 	// Turn led on of sensor that sees something
				joBot.drive(100, 100);	
			}
			if ((sr > 200) && (sr < 500)) {
				joBot.setLed(joBot.LED_YELLOW, true);
				joBot.drive(100, 100);	
			}
		}
		
		// Opdracht ???
		
		// We start with state 1 for the reactive behavior but just once
		if (state == stateInit) {
			System.out.println("Reactive Behavior");
			state = 2;
		}
		
		// This is where the Sense loop starts
		if (state == stateSense) {
			nextState = stateSense;			// Set default state
			prevSl = sl;
			prevSr = sr;
			sl = joBot.getSensorValue(0);	// Read both distance sensors
			sr = joBot.getSensorValue(1);
			if (sl < threshold && sr < threshold)
				state = stateNeutral;
			else {
				joBot.drive(0,0);
				diff = (sl - prevSl) + (sr - prevSr);
				System.out.print("ToMe=");
				System.out.println(diff);
				if (diff > 0)
					senseToMe = true;
				else
					senseToMe = false;
				if ((absDiff(prevSl, sl) > speedThreshold) ||
					(absDiff(prevSr, sr) > speedThreshold))
					senseFast = true;
				else
					senseFast = false;
				state = stateReason;
			}
		}
		
		// Now we reason with the sensor values
		if (state == stateReason) {
			if (senseFast && senseToMe)
				state = stateScared;
			if (! senseFast || ! senseToMe)
				state = stateCurious; 
		}

		// Then we act
		if (state == stateScared) {
			joBot.setStatusLeds(false, false, true);  // show scared		
//			joBot.drive(-speed, -speed);
			// Replace drive backward for obstacle lesson 9b
			avoidObstacle(sl, sr);
		}
		if (state == stateCurious) {
			joBot.setStatusLeds(false, true, false);  // show curious	
			joBot.drive(speed/2, speed/2);
		}
		if (state == stateNeutral) {
			joBot.setStatusLeds(true, false, false);  // show neutral
			rnd1 = random (0x3F);	
			rnd2 = random1 (0x3F);	
			System.out.print("R1=");
			System.out.print(rnd1);
			System.out.print(" R2=");
			System.out.println(rnd2);
			joBot.drive(rnd1, rnd2);
			wait = random(0xEF);	
			state = stateWander;
		}
		
		if (state == stateWander) {
			if (wait-- == 0)
				nextState = stateWander;
			else
				nextState = stateSense;
		}
		
		// And prepare for the next cycle
		state = nextState;
	}

	// Extra funcites die in latere opdrachten worden gebruikt.
	/**
	 * absDiff determines the difference between the two given numbers.
	 * If the result is negative, it is made into a positive number
	 * so the absolute value of the difference is returned
	 */
	
	private int absDiff (int a, int b) {
		int diff = a - b;
		if (diff < 0)
			return 0 - diff;
		return diff;
	}
	
	/**
	 * Lesson 9b - Avoid Obstacle subroutine
	 * AvoidObstacle will make sure the robot gets away from the object.
	 * It needs a number of steps to do so and will stay in the
	 * stateScared state. To execute the steps we introduce a 
	 * substate.
	 */
	
	private void avoidObstacle(int sl, int sr) {
		nextState = stateScared;	// Make sure we get back here
		if (subState < stateBackup) {
			rnd1 = random (0x3F);	
			subState = stateBackup;
			subCount = 0;
			System.out.print("Avoid obstacle: ");
			System.out.print(sl);
			System.out.print(",");
			System.out.println(sr);
			lsl = sl;
			lsr = sr;
		}
		if (subState == stateBackup) {
			if (subCount++ < 20) {
				if (lsl == lsr)
					joBot.drive(-100, -100);
				else if (lsl > lsr)
					joBot.drive(-100, -rnd1);
				else
					joBot.drive(-rnd1, -100);
			} else {
				subCount = 0;
				subState = 0;
				nextState = stateSense;
			}
		}
	}
	
	private int random (int mask) {
		return (int) System.currentTimeMillis() & mask;	
	}
	
	private int random1 (int mask) {
		return (int) (System.currentTimeMillis() >>4) & mask;	
	}

}
