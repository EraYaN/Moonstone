package javaBot.Nano.Grid;

/** 
 * CuriousBeheavior is een aangepaste versie van FleeBehavior.
 * Leerlingen passen het gedrag aan in een aantal stappen:
 * 
 * Opdracht 2g - Bekijk deze code 
 * 
 * Opdracht 2h/j - Pas de code aan:
 * 	Zorg dat de robot naar je toe komt rijden.
 * 
 * Opdracht 2k+ - Zorg dat de robot niet te dichtbij komt.
 * 	Blijf op een afstand van 5 cm. Zoek uit welke waarde dat is.
 * 	De robot zelf is ongeveer 18 cm, de sensor lijn is 25 cm.
 * 	Merk op dat de code wat anders is dan in FleeBehavior.
 *  Er zijn z.g. State variabelen toegevoegd.
 *  Dit is gedaan ter voorbereiding van latere lessen.
 
 * 	Lesson 8a - Opnemen state definities
 * 	Lesson 8b - Opnemen basis architectuur
 * 	Lesson 8c - Opnemen maken random getallen
 * 	Lesson 8d - Code voor ACT clause
 * 	Lesson 8e - Code voor SENSE clause
 * 	Lesson 8f - Code voor Reason clause
 * 
 * 	Lesson 9a - Opnemen substates
 * 	Lesson 9b - Avoid Obstacle subroutine
 */

import com.muvium.apt.PeriodicTimer;

public class CuriousBehavior08I extends Behavior
{
	// Declaraties voor opdracht 2i
	private BaseController	joBot;
	private int state = stateInit;
	private int ds = 0;
	
	// Declaraties toegevoegd voor opdracht 8
	private static final int stateInit 			= 10;
	private static final int stateSense 		= 20;
	private static final int stateSenseScared 	= 22;
	private static final int stateSenseCurious 	= 23;	
	private static final int stateReason 		= 30;
	private static final int stateSenseNeutral 	= 31;
	private static final int stateAct 			= 40;
	private static final int stateActWander 	= 41;
	
	private int threshold = 30;
	private int speedThreshold = 10;
	private int rnd1 = 0;
	private int rnd2 = 0;
	private int wait = 0;
	private int nextState = 0;
	private int prevDs = 0;
	private boolean senseFast = false;
	private boolean senseToMe = false;
	private int diff = 0;
	private int speed = 50;
	
	public CuriousBehavior08I (BaseController initJoBot, PeriodicTimer initServiceTick,
			int servicePeriod)
	{
		super(initJoBot, initServiceTick, servicePeriod);
		joBot = initJoBot;	}

	public void doBehavior()
	{
		
//==============================================================
// Opdracht 2
// =============================================================
		
		// Anders dan in FleeBehavior wordt hier de state getest.
		// Deze dient voor opdracht 2i op nul (0) te staan. 
		// In volgende lessen gaan we deze variabele gebruiken.
		// De rest van de code is hetzelfde als in FleeBehavior.
		
		if (state == 0) {
			ds = joBot.getSensorValue(joBot.SENSOR_DS);
			joBot.setStatusLeds(false, false, false);  // Turn leds off
			joBot.drive(0, 0);
			
		// Zorg voor opdracht 2j+ dat de robot niet te dichtbij komt
		// Dat doe je door gebruik te maken van een extra test
		// Die kijkt of de waarde niet hoger wordt dan bij 5cm afstand
		// Om die samen te voegen met de sensor waarde, gebruik je de
		// && (and) operator als volgt:
		// if ((sl > 200) && (sl < ???))  // Vul hier de juiste waarde in
			
			if ((ds > 200) && (ds < 500)) {
				joBot.setLed(joBot.LED_GREEN, true); 	// Turn led on of sensor that sees something
				joBot.drive(100, 100);	
			}
		}
		
//==============================================================
// Opdracht 5
// =============================================================
		
		// Om de gevoeligheid van de sensoren aan te passen
		// gebruik je de calibratiewaarden en verander je de
		// getalling in de bovenstaande If statements
		// Opdracht 5j+ - Verander gevoeligheid
		
//==============================================================
// Opdracht 8
// =============================================================
		
// We maken eerst een infrastructuur volgens het state diagram
// De robot doet nog niets, maar we kunnen dit wel testen
// De leds geven aan of de robot iets ziet
		
		if (state == stateInit) {
			System.out.println("Reactive Behavior");
			joBot.setStatusLeds(false, false, false);  
			state = stateSense;
		}	
		
//---------------------------------------------------------------
// Sense
//---------------------------------------------------------------
		
		// This is where the Sense loop starts
		if (state == stateSense) {
			// Save previous sensor values
			prevDs = ds;
			// Read new value for both distance sensors
			ds = joBot.getSensorValue(joBot.SENSOR_DS);	
			// Check if any movement
			if (ds < threshold)
				state = stateSenseNeutral;
			else {
				state = stateReason;
// Hier gaan we later de snelheid en richting bepalen	
// Opdracht 8h -------------------------------------------------------
// Bepaal snelheid en richting

				diff = (ds - prevDs);
				if (diff > threshold)
					senseToMe = true;
				else
					senseToMe = false;
				if ((absDiff(prevDs, ds) > speedThreshold))
					senseFast = true;
				else
					senseFast = false;
				System.out.print("Diff=");
				System.out.print(diff);
				System.out.print(" ToMe="); 
				System.out.print(senseToMe);
				System.out.print(" Fast=");
				System.out.println(senseFast);
			}		
		}		
		
//-----------------------------------------------------------------
// Reason
//-----------------------------------------------------------------
		
// Het redeneer gedeelte is beperkt
// We bepalen wanneer de robot bang 
// of nieuwschierig wordt
			
		if (state == stateReason) {
			if (senseFast && senseToMe)
				state = stateSenseScared;
			else if (! senseFast || ! senseToMe)
				state = stateSenseCurious; 
			else
				state = stateSenseNeutral;
		}
		
//------------------------------------------------------------------
// Act
//------------------------------------------------------------------

		// Then we act
		nextState = stateSense;
// Opdracht 8f --------------------------------------------------
		if (state == stateSenseScared) {
			joBot.setStatusLeds(false, false, true);  
			// show scared = blue	
			System.out.println("Scared");
			joBot.drive(-speed, -speed);  
			// Drive backward Opdracht 8f -----------------------
			wait = 15;	
			state = stateActWander; // Start wandering
		}
		if (state == stateSenseCurious) {
			joBot.setStatusLeds(false, true, false);  
			// show curious	= green
			System.out.println("Curious");
			joBot.drive(speed/2, speed/2);	
			// Drive forward Opdracht 8f -----------------------	
			}
		if (state == stateSenseNeutral) {
			joBot.setStatusLeds(false, false, false);  
			// show neutral = no lights
			// Random move Opdracht 8f -------------------------
			rnd1 = random (0x3F);	// Max 64
			rnd2 = random1 (0x3F);	
			wait = random(0x1F);	// Change wait to random value
			System.out.print("Wander R1=");
			System.out.print(rnd1);
			System.out.print(" R2=");
			System.out.print(rnd2);
			System.out.print(" W=");
			System.out.println(wait);
			joBot.drive(rnd1, rnd2);
			state = stateActWander;
		}	
		if (state == stateActWander) {
			joBot.setStatusLeds(true, false, false);
			// Show wandering = yellow
			if (wait-- > 0)
				nextState = stateActWander;
		}
        // And prepare for the next cycle
		state = nextState;
	}
	
// -------------------------------------------------------------------
// Extra functies die de opdrachten worden gebruikt.
// -------------------------------------------------------------------
		
// Opdracht 8e --------------------------------------------------------
	
	/**
	 * Take the current time and mask out a part of it
	 * This way the sequence in the timer is ignored somewhat
	 * random1 shifts the time to the right and then takes
	 * another part of the time.
	 * The mask size determines the maximum value
	 */
	private int random (int mask) {
		return (int) System.currentTimeMillis() & mask;	
	}
	
	private int random1 (int mask) {
		return (int) (System.currentTimeMillis() >>4) & mask;	
	}
	
	// Opdracht 8h ----------------------------------------------------
	/**
	 * absDiff determines the difference between the two given numbers.
	 * If the result is negative, it is made into a positive number
	 * so the absolute value of the difference is returned
	 */
	
	private int absDiff (int a, int b) {
		int diff = a - b;
		if (diff < 0)
			return 0 - diff;
		return diff;
	}

	
}
